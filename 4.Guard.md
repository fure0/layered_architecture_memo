# AuthGuard 説明

## 概要

`AuthGuard`は、認証済みユーザー専用のエンドポイントを保護するためのNestJS Guardである。このGuardを使用することで、ログイン済みユーザーのみがアクセスできるエンドポイントを簡単に実装できる。

## 前提条件

### SiteContextMiddlewareが必要

`AuthGuard`は`SiteContextMiddleware`が設定した`request.siteContext`に依存している。そのため、`AuthGuard`を使用する前に、`SiteContextMiddleware`がグローバルに適用されている必要がある。

`SiteContextMiddleware`は以下の処理を行う：

- `X-Site-Identifier`ヘッダーの検証
- 認証情報の抽出（JWTトークンなど）
- `SiteContext`オブジェクトの構築と`request.siteContext`への設定

### SiteContextの構造

```typescript
interface SiteContext {
  siteIdentifier: 'admin' | 'corporate' | 'portal';
  userId?: string;        // ログイン済みの場合のみ存在
  companyId?: string;    // 企業ユーザーの場合のみ存在
  permissions: string[];  // ユーザーの権限リスト
}
```

## 基本的な仕組み

### Guardの役割

`AuthGuard`は以下の2つのチェックを行う：

1. **サイトコンテキストの存在確認**
   - `SiteContextMiddleware`がリクエストに`siteContext`を設定しているか確認
   - 設定されていない場合は`InternalServerErrorException`をスロー

2. **ユーザーIDの存在確認**
   - `siteContext.userId`が存在するか確認（ログイン済みかどうか）
   - 存在しない場合は`UnauthorizedException`をスロー

### 実装コード

```typescript
// src/core/presentation/guards/auth.guard.ts 1:31
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';
import {
  UnauthorizedException,
  InternalServerErrorException,
} from '../../../core/exceptions/common.exceptions';

/**
 * 認証済みユーザー専用Guard
 */
@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<Request>();

    // サイトコンテキストが存在することを確認
    if (!request.siteContext) {
      throw new InternalServerErrorException(
        'サイトコンテキストが設定されていません',
      );
    }

    // ユーザーIDが存在することを確認（ログイン済みユーザーのみ）
    if (!request.siteContext.userId) {
      throw new UnauthorizedException('ログインが必要です');
    }

    return true;
  }
}
```

## 使用方法

### コントローラーでの適用

コントローラーのメソッドに`@UseGuards(AuthGuard)`デコレータを追加するだけで、そのエンドポイントが保護される。

```typescript
// src/modules/users/presentation/controllers/user.controller.ts　26:36
@Get('portal/member/analytics')
@UseGuards(AuthGuard)
@GetUserAnalyticsSwagger()
async getUserAnalytics(
  @GetSiteContext() siteContext: SiteContext,
): Promise<UserAnalyticsResponse> {
  const memberId = siteContext.userId;
  const userCountsInfo = await this.userService.getUserCountsInfo(memberId);

  return UserAnalyticsResponse.fromResult(memberId, userCountsInfo);
}
```

### クラスレベルでの適用

コントローラー全体に適用する場合は、クラスにデコレータを追加できる：

```typescript
@ApiTags('Users')
@Controller('api/v1/users')
@UseGuards(AuthGuard)
export class UserController {
  // すべてのメソッドが保護される
}
```

### メソッドレベルでの適用

特定のメソッドのみを保護する場合は、メソッドにデコレータを追加する：

```typescript
@Get('portal/member/profile')
@UseGuards(AuthGuard)
async getPortalMemberInfo() {
  // このメソッドのみが保護される
}
```

## エラーハンドリング

### 発生する可能性のある例外

1. **InternalServerErrorException (500)**
   - 原因: `siteContext`が設定されていない
   - メッセージ: `"サイトコンテキストが設定されていません"`

2. **UnauthorizedException (401)**
   - 原因: `siteContext.userId`が存在しない（未ログイン）
   - メッセージ: `"ログインが必要です"`

### エラーレスポンスの例

```json
{
  "statusCode": 401,
  "code": "AUTHENTICATION_REQUIRED",
  "message": "ログインが必要です",
  "timestamp": "2024-01-01T00:00:00.000Z"
}
```