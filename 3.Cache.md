# キャッシュサービス説明資料

## クイックサマリー

- **二層キャッシュ**: メモリ(60秒固定) + Redis(サイト別TTL: admin 60s / corporate 60s / portal 300s)
- **取得順序**: メモリ → Redis。ランダムではなく、メモリ優先でヒットしなければRedisを参照
- **保存動作**: メモリとRedisの両方に書き込み（メモリ60秒、Redisは設定TTL）

## 概要

`CacheService`は、ページネーションありとページネーションなしの2つのキャッシュ取得・保存方法を提供する。

- **取得メソッド**: `getList`（ページネーションあり）、`getListNoPaging`（ページネーションなし）
- **保存メソッド**: `setList`（ページネーションあり）、`setListNoPaging`（ページネーションなし）

---

## 1. CacheServiceの内部処理フロー

### 1.1 `setList` の処理フロー

**使用例**:
```typescript
await this.cacheService.setList(
  'news',
  listParams,              // ListSearchParams (page, perPage, sort含む)
  siteContext,
  resultDto,               // NewsListResultDtoインスタンス
);
```

```
1. キャッシュキー生成
   ↓
   CacheKeyBuilder.buildListKey()
   → gas-portal:news:portal:{filter_hash}:page_1:per_page_10:sort_createdAt_desc

2. DTOをPlain Objectに変換
   ↓
   data.toPlainObject()
   → Plain Object

3. JSON文字列化
   ↓
   JSON.stringify(plainData, bigIntReplacer)
   → BigIntフィールドを文字列に変換

4. TTL設定
   ↓
   - メモリキャッシュ: 60秒固定
   - Redisキャッシュ: 設定値（デフォルト60秒）

5. 複数ストアに保存
   ↓
   store.set(key, serializedData, ttlMs)
   → メモリストアとRedisストアの両方に保存
```

**コード**:
```typescript
const key = CacheKeyBuilder.buildListKey(resourceType, searchParams, siteContext);
const redisTtl = cacheConfig.ttl[siteContext.siteIdentifier] ?? 60;
const memoryTtl = 60; // インメモリキャッシュは60秒固定

const plainData = data.toPlainObject();
const serializedData = JSON.stringify(plainData, this.bigIntReplacer);

// 複数ストアに個別のTTLを設定
const stores = cacheManagerAny.stores || [];
for (let i = 0; i < stores.length; i++) {
  const store = stores[i] as unknown as Keyv;
  const ttlMs = i === 0 ? memoryTtl * 1000 : redisTtl * 1000;
  await store.set(key, serializedData, ttlMs);
}
```

---

### 1.2 `getList` の処理フロー

**使用例**:
```typescript
const cachedResult = await this.cacheService.getList(
  'news',
  listParams,              // ListSearchParams (page, perPage, sort含む)
  siteContext,
  NewsListResultDto,       // DTOコンストラクタ
);
```

```
1. キャッシュキー生成
   ↓
   CacheKeyBuilder.buildListKey()
   → gas-portal:news:portal:{filter_hash}:page_1:per_page_10:sort_createdAt_desc

2. キャッシュから取得
   ↓
   cacheManager.get(key)
   → JSON文字列

3. JSON解析
   ↓
   JSON.parse(cached, bigIntReviver)
   → BigIntフィールドを復元

4. DTO変換
   ↓
   dtoConstructor.fromPlainObject(plainData)
   → NewsListResultDtoインスタンス

5. 返却
   → DTO | null
```

**コード**:
```typescript
const key = CacheKeyBuilder.buildListKey(resourceType, searchParams, siteContext);
const cached = await this.cacheManager.get<string>(key);
if (cached) {
  const plainData = JSON.parse(cached, this.bigIntReviver);
  return dtoConstructor.fromPlainObject(plainData);
}
return null;
```

---

### 1.3 `setListNoPaging` の処理フロー

**使用例**:
```typescript
await this.cacheService.setListNoPaging(
  'news',
  { id: id },             // 任意のパラメータ
  siteContext,
  cacheableResult,        // toPlainObject()を持つオブジェクト
);
```

```
1. キャッシュキー生成
   ↓
   CacheKeyBuilder.buildListKeyNoPaging()
   → gas-portal:news:portal:{params_hash}

2. Plain Objectに変換
   ↓
   data.toPlainObject() または data（直接）
   → toPlainObject()があれば使用、なければ直接使用

3. JSON文字列化
   ↓
   JSON.stringify(plainData, bigIntReplacer)
   → BigIntフィールドを文字列に変換

4. TTL設定
   ↓
   - メモリキャッシュ: 60秒固定
   - Redisキャッシュ: 設定値（デフォルト60秒）

5. 複数ストアに保存
   ↓
   store.set(key, serialized, ttlMs)
   → メモリストアとRedisストアの両方に保存
```

**コード**:
```typescript
const key = CacheKeyBuilder.buildListKeyNoPaging(resourceType, params, siteContext);

// CacheableDtoの場合はtoPlainObject()を使用、そうでなければ直接シリアライズ
const plainData = (data as { toPlainObject?: () => unknown })
  .toPlainObject
  ? (data as { toPlainObject: () => unknown }).toPlainObject()
  : data;
const serialized = JSON.stringify(plainData, this.bigIntReplacer);

const redisTtl = cacheConfig.ttl[siteContext.siteIdentifier] ?? 60;
const memoryTtl = 60; // インメモリキャッシュは60秒固定

const stores = cacheManagerAny.stores || [];
for (let i = 0; i < stores.length; i++) {
  const store = stores[i] as unknown as Keyv;
  const ttlMs = i === 0 ? memoryTtl * 1000 : redisTtl * 1000;
  await store.set(key, serialized, ttlMs);
}
```

---

### 1.4 `getListNoPaging` の処理フロー

**使用例**:
```typescript
const cachedResult = await this.cacheService.getListNoPaging<NewsDetailResultDto>(
  'news',
  { id: id },             // 任意のパラメータ
  siteContext,
);
```

```
1. キャッシュキー生成
   ↓
   CacheKeyBuilder.buildListKeyNoPaging()
   → gas-portal:news:portal:{params_hash}

2. キャッシュから取得
   ↓
   cacheManager.get(key)
   → JSON文字列

3. JSON解析
   ↓
   JSON.parse(cached, bigIntReviver)
   → BigIntフィールドを復元

4. 返却
   → パースされたオブジェクト | null
```

**コード**:
```typescript
const key = CacheKeyBuilder.buildListKeyNoPaging(resourceType, params, siteContext);
const cached = await this.cacheManager.get<string>(key);
if (cached) {
  return JSON.parse(cached, this.bigIntReviver);
}
return null;
```

---

## 2. 主な違い

### 2.1 取得メソッドの比較

| 項目 | `getList` | `getListNoPaging` |
|------|-----------|-------------------|
| **用途** | ページネーションありのリスト | 詳細取得・全件取得 |
| **キー形式** | ページネーション情報を含む | パラメータハッシュのみ |
| **DTO変換** | あり（コンストラクタ使用） | なし（直接返却） |
| **使用例** | お知らせ一覧 | お知らせ詳細 |

### 2.2 保存メソッドの比較

| 項目 | `setList` | `setListNoPaging` |
|------|-----------|-------------------|
| **用途** | ページネーションありのリスト保存 | 詳細・全件データ保存 |
| **キー形式** | ページネーション情報を含む | パラメータハッシュのみ |
| **シリアライズ** | DTOの`toPlainObject()`必須 | `toPlainObject()`があれば使用、なければ直接 |
| **TTL** | メモリ60秒、Redis設定値 | メモリ60秒、Redis設定値 |
| **ストア** | メモリ＋Redis両方に保存 | メモリ＋Redis両方に保存 |
| **使用例** | お知らせ一覧保存 | お知らせ詳細保存 |

---

## 3. まとめ

### 取得メソッド
- **`getList`**: ページネーション対応のリスト取得に使用
- **`getListNoPaging`**: 単一オブジェクトや全件取得に使用
- どちらもBigIntの自動復元機能を提供
- エラー時は`null`を返却して処理を継続

### 保存メソッド
- **`setList`**: ページネーション対応のリスト保存に使用
- **`setListNoPaging`**: 単一オブジェクトや全件データ保存に使用
- どちらもBigIntの自動文字列化機能を提供
- メモリキャッシュとRedisキャッシュの両方に保存（個別のTTL設定）
- エラー時はログ出力のみで処理を継続

