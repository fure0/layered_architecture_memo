# Domain層（ドメイン層）詳細ドキュメント

## 概要

Domain層は、レイヤードアーキテクチャの中核を担う層で、ビジネスルールとドメインロジックを実装します。この層は技術的な詳細から完全に独立しており、純粋なビジネス概念とルールのみを表現します。

## レイヤードアーキテクチャにおけるDomain層の重要な役割

### Domain層の位置づけ

```
┌─────────────────────────────────────────────────────────────┐
│                   Presentation Layer                        │
│                           ↓                                 │
│                   Application Layer                         │
│                           ↓                                 │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                  Domain Layer                           ││
│  │              (ビジネスルールの中核)                           ││
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        ││
│  │  │  Entities   │ │   Policies  │ │Value Objects│        ││
│  │  └─────────────┘ └─────────────┘ └─────────────┘        ││
│  │  ┌─────────────┐ ┌─────────────┐                        ││
│  │  │Repositories │ │Specifications│                       ││
│  │  │(Interface)  │ │             │                        ││
│  │  └─────────────┘ └─────────────┘                        ││
│  └─────────────────────────────────────────────────────────┘│
│                           ↑                                 │
│                Infrastructure Layer                         │
│                    (実装の詳細)                                │
└─────────────────────────────────────────────────────────────┘
```

### 1. ビジネスルールの中央集権化
- **純粋なビジネスロジック**: 技術的詳細に依存しない業務ルール
- **ドメインエキスパートとの共通言語**: ビジネス概念の正確な表現
- **不変性の保証**: ビジネスルールの一貫性と整合性

### 2. 依存性逆転の原則の実現
- **インターフェース定義**: Infrastructure層が実装すべき契約
- **技術的詳細からの独立**: データベースやフレームワークに依存しない
- **テスタビリティ**: 外部依存なしでビジネスロジックをテスト可能

### 3. ドメイン駆動設計（DDD）の実践
- **エンティティ**: ビジネス概念の中心的オブジェクト
- **値オブジェクト**: 不変で交換可能な値の表現
- **ポリシー**: ビジネスルールの明示的な実装
- **仕様**: 複雑な条件の組み合わせ可能な表現

---

## Domain層の詳細

### Entities（エンティティ）

#### 1. service.entity.ts
**役割**: サービスのビジネス概念を表現する中核エンティティ

**主要な責務**:
- **ビジネス状態の管理**: サービスの各種ステータスと属性
- **ビジネスルールの実装**: 公開判定、承認状態、企業所属判定
- **ドメインロジック**: サービス固有の業務ルール

**レイヤードアーキテクチャにおける重要性**:
- **ビジネス概念の中心**: サービスドメインの核となるオブジェクト
- **不変性の保証**: readonlyプロパティによる状態保護
- **Value Objectの活用**: ServiceId、ServiceNameによる型安全性

**主要なビジネスメソッド**:
```typescript
isPublic()              // 公開状態の判定
isApproved()           // 承認状態の判定
isDraft()              // 下書き状態の判定
getApiStatus()         // API用ステータス変換
belongsToCompany()     // 企業所属判定
getTags()              // タグ情報の正規化
```

**なぜ必要か**:
- ビジネスルールの一元化
- データの整合性保証
- ドメインエキスパートとの共通言語

**いつ使用するか**:
- サービス情報の操作時
- ビジネスルール適用時
- 状態判定が必要な時

### Policies（ポリシー）

#### 1. service-access.policy.ts
**役割**: サービスアクセスに関するビジネスポリシーの実装

**主要な責務**:
- **アクセス制御ルール**: サイト別のアクセス権限判定
- **表示フィールド制御**: サイト別の情報公開範囲
- **機能アクセス制御**: ダウンロード、統計情報等の機能制限

**レイヤードアーキテクチャにおける重要性**:
- **ビジネスポリシーの明示化**: 複雑なアクセス制御ルールの可視化
- **サイト別ルールの統一**: 一貫したセキュリティポリシー
- **変更の局所化**: ポリシー変更の影響範囲限定

**サイト別アクセス制御**:
```typescript
ADMIN: 全データアクセス + 管理機能
CORPORATE: 自社データのみ + 編集機能
PORTAL: 公開データのみ + ダウンロード機能
```

**主要メソッド**:
```typescript
canAccessService()        // 個別サービスアクセス判定
canAccessServiceList()    // サービス一覧アクセス判定
getVisibleFields()        // 表示可能フィールド取得
canAccessStatistics()     // 統計情報アクセス判定
canDownloadResources()    // ダウンロード権限判定
```

**なぜ必要か**:
- 複雑なアクセス制御の体系化
- セキュリティポリシーの一元管理
- ビジネスルールの明確な表現

**いつ使用するか**:
- アクセス権限チェック時
- 表示内容の決定時
- 機能利用可否の判定時

### Repositories（リポジトリインターフェース）

#### 1. service.repository.interface.ts
**役割**: データアクセスの抽象化インターフェース

**主要な責務**:
- **データアクセス契約**: Infrastructure層が実装すべきメソッド定義
- **検索条件の標準化**: ServiceSearchCriteriaによる統一的な検索仕様
- **ドメイン層の独立性**: 技術的詳細からの分離

**レイヤードアーキテクチャにおける重要性**:
- **依存性逆転の実現**: Domain層がInfrastructure層に依存しない
- **テスタビリティ**: モックによる単体テスト可能
- **技術的柔軟性**: データストア変更時の影響局所化

**定義されるメソッド**:
```typescript
findByCriteria()          // 条件検索
findById()               // ID検索
findByServiceId()        // サービスID検索
findByCompanyId()        // 企業別検索
findPublicServices()     // 公開サービス検索
countByCriteria()        // 件数取得
exists()                 // 存在確認
```

**ServiceSearchCriteria**:
- ページネーション情報
- ソート条件
- 検索キーワード
- フィルタ条件
- 関連データ取得設定

**なぜ必要か**:
- データアクセスの抽象化
- ビジネスロジックとデータ層の分離
- 将来的な技術変更への対応

**いつ使用するか**:
- データ取得が必要な時
- 検索機能の実装時
- テスト時のモック作成

#### 2. service.repository.token.ts
**役割**: 依存性注入用のトークン定義

**内容**:
```typescript
export const SERVICE_REPOSITORY_TOKEN = Symbol('ServiceRepository');
```

**レイヤードアーキテクチャにおける重要性**:
- **依存性注入の実現**: インターフェースと実装の結合
- **型安全性**: TypeScriptのSymbolによる一意性保証
- **モジュール間の疎結合**: 実装詳細の隠蔽

**なぜ必要か**:
- NestJSの依存性注入システムとの統合
- インターフェースベースの設計
- テスト時の実装切り替え

**いつ使用するか**:
- モジュール設定時
- 依存性注入時
- テスト設定時

### Specifications（仕様）

#### 1. service-search.specification.ts
**役割**: 検索条件の構築と検証に関する仕様

**主要な責務**:
- **サイト別検索条件**: コンテキストに応じた条件調整
- **バリデーション**: 検索パラメータの妥当性チェック
- **条件の正規化**: 統一的な検索条件の構築

**レイヤードアーキテクチャにおける重要性**:
- **複雑な条件の体系化**: 組み合わせ可能な検索仕様
- **ビジネスルールの適用**: サイト別制約の実装
- **再利用性**: 共通的な検索ロジックの抽象化

**サイト別条件調整**:
```typescript
ADMIN: 全データ検索可能
CORPORATE: 自社データに限定
PORTAL: 公開データに限定
```

**主要メソッド**:
```typescript
buildCriteria()           // 検索条件構築
validateSortField()       // ソート条件検証
validatePagination()      // ページネーション検証
validateSearchKeyword()   // キーワード検証
validateFilters()         // フィルタ検証
adjustIncludes()          // 関連データ取得調整
```

**なぜ必要か**:
- 複雑な検索条件の管理
- サイト別制約の実装
- 検索ロジックの再利用

**いつ使用するか**:
- 検索条件構築時
- 入力値検証時
- サイト別制約適用時

### Value Objects（値オブジェクト）

#### 1. service-id.vo.ts
**役割**: サービスIDの値オブジェクト

**主要な責務**:
- **形式検証**: ESV + 7桁数字の形式チェック
- **不変性保証**: 一度作成されたら変更不可
- **型安全性**: プリミティブ型の誤用防止

**レイヤードアーキテクチャにおける重要性**:
- **ドメイン概念の明確化**: IDという概念の型安全な表現
- **バリデーションの集約**: ID形式チェックの一元化
- **誤用の防止**: 文字列との混同を防ぐ

**実装パターン**:
```typescript
private constructor()     // 直接インスタンス化を防止
static create()          // ファクトリメソッド
private validate()       // 内部バリデーション
getValue()              // 値の取得
equals()                // 等価性判定
```

**バリデーションルール**:
- 必須チェック
- ESV + 7桁数字の形式チェック

**なぜ必要か**:
- 型安全性の向上
- ビジネスルールの表現
- 誤用の防止

**いつ使用するか**:
- サービスID操作時
- エンティティ作成時
- ID比較時

#### 2. service-name.vo.ts
**役割**: サービス名の値オブジェクト

**主要な責務**:
- **長さ制限**: 100文字以内の制約
- **必須チェック**: 空文字列の防止
- **不変性保証**: 一度作成されたら変更不可

**レイヤードアーキテクチャにおける重要性**:
- **ビジネス制約の実装**: サービス名に関するルール
- **データ品質の保証**: 不正な名前の防止
- **型安全性**: 文字列との区別

**バリデーションルール**:
- 必須チェック
- 100文字以内の長さ制限

**なぜ必要か**:
- データ品質の保証
- ビジネス制約の実装
- 型安全性の向上

**いつ使用するか**:
- サービス名設定時
- エンティティ作成時
- 名前変更時

---

## Domain層の設計パターン

### 1. Entity Pattern
**目的**: ビジネス概念の中心的オブジェクト

**特徴**:
- 一意性を持つ（ID）
- ライフサイクルを持つ
- ビジネスロジックを含む

### 2. Value Object Pattern
**目的**: 不変で交換可能な値の表現

**特徴**:
- 不変性（Immutable）
- 等価性による比較
- 自己検証

### 3. Policy Pattern
**目的**: 複雑なビジネスルールの明示化

**特徴**:
- ルールの可視化
- 条件の組み合わせ
- 変更の局所化

### 4. Specification Pattern
**目的**: 複雑な条件の組み合わせ可能な表現

**特徴**:
- 条件の再利用
- 組み合わせ可能
- 可読性の向上

### 5. Repository Pattern
**目的**: データアクセスの抽象化

**特徴**:
- インターフェース定義
- 技術的詳細の隠蔽
- テスタビリティ

---

## Domain層の設計原則

### 1. 技術的詳細からの独立
- データベースに依存しない
- フレームワークに依存しない
- 外部APIに依存しない

### 2. ビジネスルールの中央集権化
- 重複の排除
- 一貫性の保証
- 変更の局所化

### 3. ドメインエキスパートとの共通言語
- ユビキタス言語の使用
- ビジネス概念の正確な表現
- コミュニケーションの改善

### 4. 不変性の重視
- 状態変更の制御
- 副作用の防止
- 予測可能な動作

---

## 使用場面とベストプラクティス

### Entities
- **使用場面**: ビジネス概念の中心的操作
- **ベストプラクティス**: 
  - 不変性の保証
  - ビジネスメソッドの実装
  - Value Objectの活用

### Policies
- **使用場面**: 複雑なビジネスルール適用
- **ベストプラクティス**:
  - ルールの明示化
  - 条件の組み合わせ
  - テスタビリティ

### Value Objects
- **使用場面**: 型安全な値の表現
- **ベストプラクティス**:
  - 不変性の実装
  - 自己検証
  - ファクトリメソッド

### Specifications
- **使用場面**: 複雑な条件の構築
- **ベストプラクティス**:
  - 条件の再利用
  - 組み合わせ可能性
  - 可読性の重視

### Repository Interfaces
- **使用場面**: データアクセスの抽象化
- **ベストプラクティス**:
  - インターフェース設計
  - 依存性逆転
  - テスト容易性

Domain層は、レイヤードアーキテクチャの心臓部として、ビジネスルールとドメインロジックを純粋に表現し、システム全体の価値を決定する重要な層です。技術的詳細から独立することで、ビジネスの変化に柔軟に対応し、長期的な保守性を確保します。
