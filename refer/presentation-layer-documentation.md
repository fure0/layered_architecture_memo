# Presentation層（プレゼンテーション層）詳細ドキュメント

## 概要

Presentation層は、レイヤードアーキテクチャの最上位層で、外部からのリクエストを受け取り、適切なレスポンスを返す責務を担います。この層は、HTTPプロトコル、API仕様、データ形式などの外部インターフェースに関する詳細を管理し、ビジネスロジックを外部の技術的詳細から保護します。

## レイヤードアーキテクチャにおけるPresentation層の重要な役割

### Presentation層の位置づけ

```
┌─────────────────────────────────────────────────────────────┐
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                Presentation Layer                       │ │
│  │              (外部インターフェース)                        │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │ │
│  │  │Controllers  │ │ Decorators  │ │    DTOs     │        │ │
│  │  │             │ │             │ │             │        │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘        │ │
│  └─────────────────────────────────────────────────────────┘ │
│                           ↓                                 │
│                   Application Layer                          │
│                           ↓                                 │
│                     Domain Layer                             │
│                           ↓                                 │
│                Infrastructure Layer                          │
└─────────────────────────────────────────────────────────────┘
```

### 1. 外部インターフェースの管理
- **HTTPリクエスト処理**: RESTful APIエンドポイントの提供
- **データ変換**: 外部形式と内部形式の相互変換
- **API仕様の定義**: OpenAPI/Swaggerによる明確な仕様

### 2. 入力検証とセキュリティ
- **リクエスト検証**: 入力データの形式と妥当性チェック
- **認証・認可**: サイトコンテキストによるアクセス制御
- **エラーハンドリング**: 適切なHTTPステータスコードとエラーメッセージ

### 3. レスポンス形式の統一
- **JSON API仕様**: 一貫したレスポンス構造
- **ページネーション**: 大量データの効率的な分割提供
- **関連データ**: includeパラメータによる柔軟なデータ取得

---

## Presentation層の詳細

### Controllers（コントローラー）

#### 1. service.controller.ts
**役割**: サービス一覧取得APIのエンドポイント実装

**主要な責務**:
- **HTTPリクエスト処理**: GET /api/v1/contents/servicesエンドポイント
- **パラメータ変換**: クエリパラメータからApplication層DTOへの変換
- **エラーハンドリング**: 例外の適切な処理とHTTPレスポンス変換

**レイヤードアーキテクチャにおける重要性**:
- **外部インターフェースの実装**: RESTful APIの具体的な提供
- **層間の橋渡し**: HTTP世界とビジネスロジック世界の接続
- **技術的詳細の管理**: HTTPプロトコル固有の処理

**主要メソッド**:
```typescript
getServices()           // サービス一覧取得エンドポイント
buildBaseUrl()          // ページネーション用URL構築
```

**処理フロー**:
```typescript
1. HTTPリクエスト受信
2. クエリパラメータ検証
3. サイトコンテキスト取得
4. Application層DTOへ変換
5. ビジネスロジック実行
6. レスポンスDTO生成
7. HTTPレスポンス返却
```

**なぜ必要か**:
- **外部インターフェースの提供**: クライアントアプリケーションとの接点
- **プロトコル変換**: HTTPとビジネスロジックの橋渡し
- **エラー境界**: 例外の適切なHTTPエラーへの変換
- **ログ記録**: リクエスト処理の監査証跡

**いつ使用するか**:
- クライアントからAPIリクエストがあった時
- サービス一覧データが必要な時
- 検索・フィルタリング・ページネーションが必要な時

### Decorators（デコレーター）

#### 1. service.swagger.ts
**役割**: OpenAPI/Swagger仕様の定義

**主要な責務**:
- **API仕様定義**: エンドポイントの詳細な仕様記述
- **パラメータ定義**: リクエストパラメータの型と制約
- **レスポンス定義**: 成功・エラー時のレスポンス形式

**レイヤードアーキテクチャにおける重要性**:
- **API契約の明確化**: クライアントとサーバー間の明確な取り決め
- **開発効率の向上**: 自動生成されるAPI仕様書
- **テスト支援**: Swagger UIによる手動テスト機能

**定義内容**:
```typescript
- API概要とサイト別動作説明
- ヘッダーパラメータ（X-Site-Identifier等）
- クエリパラメータ（ページネーション、フィルタ等）
- レスポンス形式（成功・エラー）
- 使用例とテスト方法
```

**なぜ必要か**:
- **API仕様の文書化**: 開発者向けの明確な仕様書
- **クライアント開発支援**: フロントエンド開発者の作業効率化
- **テスト環境提供**: Swagger UIによる手動テスト
- **仕様の一貫性**: コードと仕様書の同期

**いつ使用するか**:
- API仕様書を生成する時
- 開発者がAPIの使い方を確認する時
- 手動でAPIをテストする時

### DTOs（Data Transfer Objects）

#### Request DTOs

##### 1. service-list-query.dto.ts
**役割**: サービス一覧取得リクエストの入力検証

**主要な責務**:
- **入力検証**: クエリパラメータの型と制約チェック
- **データ変換**: 文字列パラメータから適切な型への変換
- **ビジネスルール適用**: 検索条件の妥当性検証

**レイヤードアーキテクチャにおける重要性**:
- **入力品質保証**: 不正なデータの早期検出
- **型安全性**: TypeScriptの型システム活用
- **セキュリティ**: 悪意のある入力の防止

**検証項目**:
```typescript
- ページネーション: page（1以上）、per_page（1-100）
- ソート: 許可されたフィールドのみ
- フィルタ: ステータス、カテゴリ、企業ID、日付範囲
- 検索: キーワード文字列
- 関連データ: include条件
```

**バリデーション機能**:
```typescript
validateDates()         // 日付範囲の妥当性チェック
validateIncludes()      // include条件の妥当性チェック
validateAll()           // 全体的なバリデーション
```

**なぜ必要か**:
- **データ品質の保証**: 不正な入力データの防止
- **エラーの早期発見**: ビジネスロジック実行前の検証
- **セキュリティの向上**: インジェクション攻撃等の防止
- **開発効率**: 明確なエラーメッセージによるデバッグ支援

**いつ使用するか**:
- HTTPリクエストを受信した時
- パラメータの妥当性を確認する時
- エラーメッセージを生成する時

#### Response DTOs

##### 1. service-collection.response.ts
**役割**: サービス一覧レスポンスの構造化

**主要な責務**:
- **レスポンス構造化**: JSON API仕様に準拠したデータ構造
- **ページネーション**: メタデータとリンク生成
- **関連データ**: includeパラメータに応じた関連情報

**レイヤードアーキテクチャにおける重要性**:
- **外部形式の統一**: 一貫したAPIレスポンス構造
- **クライアント支援**: フロントエンド開発の効率化
- **拡張性**: 将来的な機能追加への対応

**レスポンス構造**:
```typescript
{
  data: ServiceResourceResponse[],     // サービスデータ配列
  meta: PaginationMeta,               // ページネーション情報
  links: PaginationLinks,             // ページネーションリンク
  included?: IncludedResourceResponse[] // 関連データ（オプション）
}
```

**主要機能**:
```typescript
fromResult()            // Application層結果からレスポンス生成
generateLinks()         // ページネーションリンク生成
generateIncluded()      // 関連データ生成
empty()                 // 空のレスポンス生成
```

**なぜ必要か**:
- **API仕様の統一**: 一貫したレスポンス形式
- **クライアント開発支援**: 予測可能なデータ構造
- **ページネーション**: 大量データの効率的な処理
- **関連データ**: N+1問題の回避とパフォーマンス最適化

**いつ使用するか**:
- サービス一覧データをクライアントに返す時
- ページネーション情報が必要な時
- 関連データを含める時

##### 2. service-resource.response.ts
**役割**: 個別サービスリソースの表現

**主要な責務**:
- **サービス属性**: ビジネスデータの外部表現
- **サイト別フィールド**: コンテキストに応じた情報提供
- **関連データ**: リレーションシップの表現

**レイヤードアーキテクチャにおける重要性**:
- **ドメインモデル変換**: 内部エンティティから外部表現への変換
- **アクセス制御**: サイト別の情報公開制御
- **データ最適化**: 必要な情報のみの提供

**サイト別フィールド**:
```typescript
Admin: view_count, conversion_rate, created_by, updated_by, internal_notes
Corporate: edit_url, statistics, approval_status
Portal: download_url, is_favorite, downloaded_at
```

**主要機能**:
```typescript
fromEntity()            // ServiceEntityからレスポンス生成
```

**なぜ必要か**:
- **データ表現の最適化**: 用途に応じた情報提供
- **セキュリティ**: 権限に応じた情報制御
- **パフォーマンス**: 不要なデータの除外
- **拡張性**: 新しいフィールドの追加容易性

**いつ使用するか**:
- サービスデータをクライアントに返す時
- サイト別の情報制御が必要な時
- 関連データを含める時

---

## Presentation層の設計パターン

### 1. Controller Pattern
**目的**: HTTPリクエストの処理とレスポンス生成

**特徴**:
- 薄いコントローラー（ビジネスロジックを含まない）
- 適切な責務分離
- エラーハンドリングの統一

### 2. DTO Pattern
**目的**: 層間のデータ転送最適化

**特徴**:
- 入力検証の集約
- 型安全性の確保
- 外部形式の統一

### 3. Decorator Pattern
**目的**: 横断的関心事の実装

**特徴**:
- メタデータの付与
- 再利用可能な機能
- 宣言的な設定

---

## レイヤードアーキテクチャにおけるPresentation層の価値

### 1. 外部インターフェースの統一
従来のアプローチでは、各エンドポイントが独自の形式でデータを返すため、クライアント側の実装が複雑になります。Presentation層により、統一されたJSON API仕様に基づく一貫したインターフェースを提供できます。

### 2. ビジネスロジックの保護
HTTPプロトコルやAPI仕様の変更が、ビジネスロジックに影響を与えることを防ぎます。例えば、REST APIからGraphQLへの移行時も、Application層以下は変更不要です。

### 3. 開発効率の向上
明確なAPI仕様とSwagger UIにより、フロントエンド開発者は実装完了前からAPIの動作を理解し、並行開発が可能になります。

### 4. セキュリティの強化
入力検証、認証・認可、エラーハンドリングを一元化することで、セキュリティホールの発生を防ぎ、一貫したセキュリティポリシーを適用できます。

### 5. 保守性の向上
各コンポーネントが明確な責務を持つため、機能追加や変更時の影響範囲が限定され、安全な修正が可能です。

---

## 使用場面とベストプラクティス

### Controllers
- **使用場面**: HTTPエンドポイントの実装
- **ベストプラクティス**:
  - 薄いコントローラーの維持
  - 適切なエラーハンドリング
  - ログ記録の実装

### Decorators
- **使用場面**: API仕様の定義、横断的機能の実装
- **ベストプラクティス**:
  - 詳細な仕様記述
  - 実例の提供
  - テスト方法の説明

### Request DTOs
- **使用場面**: 入力データの検証
- **ベストプラクティス**:
  - 包括的なバリデーション
  - 明確なエラーメッセージ
  - 型安全性の確保

### Response DTOs
- **使用場面**: 出力データの構造化
- **ベストプラクティス**:
  - 一貫した構造
  - 適切な情報制御
  - パフォーマンス最適化

Presentation層は、レイヤードアーキテクチャにおいて外部世界とシステム内部を繋ぐ重要な境界として機能し、一貫したインターフェース、適切なセキュリティ、優れた開発体験を提供します。
