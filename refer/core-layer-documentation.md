# Core層（コア機能）詳細ドキュメント

## 概要

Core層は、アプリケーション全体で共通して使用される横断的関心事（Cross-cutting Concerns）を担当する層です。レイヤードアーキテクチャにおいて、すべての層から参照可能な基盤機能を提供します。

## レイヤードアーキテクチャにおけるCore層の重要な役割

### 1. 依存関係の逆転を支援
レイヤードアーキテクチャでは「上位層が下位層に依存する」という原則がありますが、Core層は特別な位置づけにあります：

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                       │
│                           ↓                                 │
│                    Application Layer                        │
│                           ↓                                 │
│                      Domain Layer                           │
│                           ↓                                 │
│                 Infrastructure Layer                        │
└─────────────────────────────────────────────────────────────┘
                           ↑
                    Core Layer
              （全層から参照可能）
```

- **Infrastructure層**: データベース、外部API、ファイルシステムなど外部リソースとの具体的な連携
- **Core層**: アプリケーション内部の共通基盤機能（ログ、キャッシュ、認証基盤など）

### 2. 横断的関心事の一元管理
各層で個別に実装すると重複や不整合が発生する機能を一元化：

- **ログ機能**: 全層で統一されたログ出力形式とレベル管理
- **キャッシュ機能**: パフォーマンス向上のための共通キャッシュ戦略
- **認証・認可**: サイト別セキュリティポリシーの統一実装
- **例外処理**: 一貫したエラーレスポンス形式の提供

### 3. 技術的複雑性の隠蔽
各層のビジネスロジックから技術的な詳細を隠蔽し、開発者が本質的な問題に集中できるようにします：

- **Presentation層**: HTTPリクエスト処理に集中（認証詳細はCore層が処理）
- **Application層**: ビジネスロジック調整に集中（ログ詳細はCore層が処理）
- **Domain層**: ドメインルールに集中（キャッシュ詳細はCore層が処理）
- **Infrastructure層**: データアクセスに集中（共通設定はCore層が提供）

### 4. 保守性と拡張性の向上
Core層の適切な設計により、システム全体の品質が向上：

- **変更の局所化**: 共通機能の変更がCore層内で完結
- **テストの容易性**: 各層が技術的詳細に依存せずテスト可能
- **新機能の追加**: 既存の基盤機能を活用した迅速な開発
- **技術スタックの変更**: Core層の実装変更で全体に影響を与えずに技術移行可能

### 5. 品質の統一
アプリケーション全体で一貫した品質基準を保証：

- **セキュリティ**: 統一された認証・認可メカニズム
- **パフォーマンス**: 効率的なキャッシュ戦略とデータベース接続管理
- **監視性**: 構造化されたログとメトリクス収集
- **エラーハンドリング**: 予測可能で一貫したエラー処理

### 6. 開発効率の向上
共通機能の再利用により開発速度が向上：

- **ボイラープレートコードの削減**: 共通処理の自動化
- **開発者の学習コスト削減**: 統一されたパターンとインターフェース
- **デバッグの効率化**: 一元化されたログとエラー処理
- **コードレビューの効率化**: 共通パターンによる予測可能な実装

このように、Core層はレイヤードアーキテクチャの成功において極めて重要な役割を果たし、システム全体の品質、保守性、開発効率に大きく貢献します。

## ディレクトリ構成

```
src/core/
├── infrastructure/          # インフラストラクチャ関連の基盤機能
│   ├── cache/              # キャッシュ機能
│   ├── database/           # データベース接続
│   └── logging/            # ログ機能
└── presentation/           # プレゼンテーション層の共通機能
    ├── decorators/         # カスタムデコレータ
    ├── filters/            # 例外フィルタ
    ├── guards/             # ガード
    └── middleware/         # ミドルウェア
```

---

## Infrastructure（インフラストラクチャ基盤）

### Cache（キャッシュ機能）

#### 1. cache.interface.ts
**役割**: キャッシュマネージャーの型定義とインターフェース

**内容**:
- `KeyvStore`: Keyvストアの型定義
- `RedisClient`: Redisクライアントの型定義  
- `ExtendedCacheManager`: 拡張キャッシュマネージャーのインターフェース
- `CacheManager`: 基本キャッシュマネージャーのインターフェース
- `isExtendedCacheManager()`: 型ガード関数

**なぜ必要か**: 
- TypeScriptの型安全性を確保
- 複数のキャッシュストア（メモリ、Redis）を統一的に扱うため
- 将来的なキャッシュシステムの変更に対する柔軟性を提供

**いつ使用するか**:
- キャッシュサービスの実装時
- キャッシュマネージャーの型チェック時

#### 2. cache.config.ts
**役割**: キャッシュの設定管理

**内容**:
- Redis接続設定（ホスト、ポート）
- サイト別TTL設定（admin: 1分、corporate: 1分、portal: 5分）
- キープレフィックス設定

**なぜ必要か**:
- 環境別の設定を一元管理
- サイト特性に応じたキャッシュ戦略の実装
- 設定変更の容易性

**いつ使用するか**:
- キャッシュモジュールの初期化時
- キャッシュキー生成時
- TTL設定時

#### 3. cache.module.ts
**役割**: キャッシュモジュールの依存性注入設定

**内容**:
- NestJS CacheModuleの設定
- 多層キャッシュ（メモリ + Redis）の構成
- CacheServiceの提供

**なぜ必要か**:
- 高速なメモリキャッシュとスケーラブルなRedisキャッシュの組み合わせ
- アプリケーション全体でのキャッシュ機能の統一
- 依存性注入による疎結合の実現

**いつ使用するか**:
- アプリケーション起動時
- 他のモジュールでキャッシュ機能が必要な時

#### 4. cache.service.ts
**役割**: キャッシュ操作の具体的な実装

**主要機能**:
- `getServiceList()`: サービス一覧のキャッシュ取得
- `setServiceList()`: サービス一覧のキャッシュ保存
- `invalidateByPattern()`: パターンマッチングによる無効化
- `invalidateAllServiceLists()`: 全サービスリストキャッシュの無効化
- `getCacheStats()`: キャッシュ統計情報取得
- `healthCheck()`: キャッシュの健全性チェック

**なぜ必要か**:
- データベースアクセスの削減によるパフォーマンス向上
- サイト別の適切なキャッシュ戦略の実装
- システム負荷の軽減

**いつ使用するか**:
- サービス一覧取得時
- データ更新時のキャッシュ無効化
- システム監視時の統計情報取得

#### 5. cache-key.builder.ts
**役割**: キャッシュキーの生成とパターン管理

**主要機能**:
- `buildServiceListKey()`: サービス一覧用キーの生成
- `generateFilterHash()`: フィルタ条件のハッシュ化
- `buildCategoryPattern()`: カテゴリ別無効化パターン
- `buildCompanyPattern()`: 企業別無効化パターン

**なぜ必要か**:
- 一意で意味のあるキャッシュキーの生成
- 効率的なキャッシュ無効化の実現
- キャッシュキーの命名規則の統一

**いつ使用するか**:
- キャッシュの保存・取得時
- 特定条件でのキャッシュ無効化時

### Database（データベース接続）

#### 1. prisma.module.ts
**役割**: Prismaクライアントのグローバルモジュール設定

**内容**:
- `@Global()`デコレータによる全モジュールでの利用可能化
- PrismaServiceの提供とエクスポート

**なぜ必要か**:
- アプリケーション全体でのデータベース接続の統一
- 依存性注入による疎結合の実現
- 接続プールの効率的な管理

**いつ使用するか**:
- アプリケーション起動時
- データベースアクセスが必要な全モジュール

#### 2. prisma.service.ts
**役割**: Prismaクライアントのライフサイクル管理

**主要機能**:
- `onModuleInit()`: モジュール初期化時のDB接続
- `onModuleDestroy()`: モジュール破棄時のDB切断
- PrismaClientの拡張

**なぜ必要か**:
- データベース接続の適切な管理
- アプリケーションのライフサイクルとの同期
- リソースリークの防止

**いつ使用するか**:
- アプリケーション起動・終了時
- データベース操作が必要な全ての場面

### Logging（ログ機能）

#### 1. logger.interface.ts
**役割**: ログ機能のインターフェース定義

**内容**:
- `LogLevel`: ログレベルの列挙型（DEBUG, INFO, WARN, ERROR）
- `LogContext`: ログコンテキストの型定義
- `LoggerInterface`: ログ機能のインターフェース

**なぜ必要か**:
- ログ機能の標準化
- 将来的なログシステム変更への対応
- 型安全なログ出力の保証

**いつ使用するか**:
- ログサービスの実装時
- ログ出力が必要な全ての場面

#### 2. logger.module.ts
**役割**: ログサービスの依存性注入設定

**内容**:
- `LOGGER_TOKEN`: 依存性注入用のトークン定義
- `@Global()`による全モジュールでの利用可能化
- ApplicationLoggerServiceの提供

**なぜ必要か**:
- アプリケーション全体での統一されたログ機能
- 依存性注入による疎結合
- ログサービスの一元管理

**いつ使用するか**:
- アプリケーション起動時
- ログ出力が必要な全モジュール

#### 3. application-logger.service.ts
**役割**: ログ機能の具体的な実装

**主要機能**:
- `debug()`, `info()`, `warn()`, `error()`: レベル別ログ出力
- `shouldLog()`: ログレベルフィルタリング
- `createLogEntry()`: 構造化ログエントリの作成
- `outputToConsole()`: コンソール出力

**設定項目**:
- `LOG_LEVEL`: 出力するログレベル
- `ENABLE_CONSOLE_LOG`: コンソール出力の有効/無効
- `STRUCTURED_LOGGING`: 構造化ログ（JSON）の有効/無効

**なぜ必要か**:
- 統一されたログフォーマット
- 環境別のログ設定
- デバッグとトラブルシューティングの支援

**いつ使用するか**:
- エラー発生時
- デバッグ情報の出力時
- システム監視時

---

## Presentation（プレゼンテーション共通機能）

### Decorators（カスタムデコレータ）

#### 1. site-context.decorator.ts
**役割**: サイトコンテキストを取得するパラメータデコレータ

**機能**:
- `@GetSiteContext()`: リクエストからサイトコンテキストを抽出
- サイトコンテキストの存在チェック
- エラーハンドリング

**使用例**:
```typescript
@Get()
async getServices(@GetSiteContext() siteContext: SiteContext) {
  // siteContextが保証されている
}
```

**なぜ必要か**:
- コントローラーでのサイトコンテキスト取得の簡素化
- 型安全性の確保
- コードの可読性向上

**いつ使用するか**:
- サイト別処理が必要なコントローラーメソッド
- サイトコンテキストに基づく認可が必要な場面

#### 2. site-identifier.decorator.ts
**役割**: X-Site-Identifierヘッダーから直接サイト識別子を取得

**機能**:
- `@GetSiteIdentifier()`: ヘッダーからサイト識別子を抽出
- サイト識別子の妥当性チェック
- バリデーションエラーの処理

**使用例**:
```typescript
@Get()
async getServices(@GetSiteIdentifier() siteIdentifier: SiteIdentifier) {
  // siteIdentifierが直接取得できる
}
```

**なぜ必要か**:
- ヘッダー値の直接取得と検証
- 軽量なサイト識別子チェック
- ミドルウェア処理前の早期バリデーション

**いつ使用するか**:
- サイト識別子のみが必要な場面
- 軽量な処理でサイト判定が必要な時

### Filters（例外フィルタ）

#### 1. http-exception.filter.ts
**役割**: アプリケーション全体の例外処理とエラーレスポンス統一

**機能**:
- `BaseException`: カスタム例外の処理
- `HttpException`: NestJS標準例外の処理
- 予期しない例外の処理
- 統一されたエラーレスポンス形式

**エラーレスポンス形式**:
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "エラーメッセージ",
    "details": {},
    "status": 400
  }
}
```

**なぜ必要か**:
- 一貫したエラーレスポンス形式
- クライアント側でのエラーハンドリング統一
- セキュリティ向上（内部エラーの隠蔽）

**いつ使用するか**:
- アプリケーション全体での例外発生時
- API仕様に準拠したエラーレスポンスが必要な時

### Guards（ガード）

#### 1. site-context.guard.ts
**役割**: サイトコンテキストの存在を保証するガード

**機能**:
- `canActivate()`: サイトコンテキストの存在チェック
- 未設定時のエラーレスポンス
- ミドルウェアとの連携確認

**なぜ必要か**:
- コントローラー実行前のサイトコンテキスト保証
- セキュリティの向上
- エラーの早期検出

**いつ使用するか**:
- サイトコンテキストが必須のエンドポイント
- ミドルウェアの設定確認が必要な時

### Middleware（ミドルウェア）

#### 1. site-context.middleware.ts
**役割**: サイトコンテキストの構築と認証・認可処理

**主要機能**:
- X-Site-Identifierヘッダーの検証
- サイト別認証要件のチェック
- 認証情報の抽出（仮実装）
- サイト別権限の付与
- サイトコンテキストの構築

**サイト別処理**:
- **admin**: 管理者認証必須、全データアクセス権限
- **corporate**: 企業認証必須、自社データアクセス権限
- **portal**: 認証任意、公開データアクセス権限

**なぜ必要か**:
- サイト別のセキュリティポリシー実装
- 統一されたサイトコンテキスト提供
- 認証・認可の一元管理

**いつ使用するか**:
- 全APIリクエストの前処理
- サイト別アクセス制御が必要な時

---

## Core層の設計思想

### 1. 横断的関心事の分離
- ログ、キャッシュ、データベース接続などの技術的関心事を分離
- ビジネスロジックからインフラストラクチャの詳細を隠蔽

### 2. 依存性注入の活用
- `@Global()`デコレータによる全モジュールでの利用
- インターフェースベースの設計による疎結合

### 3. 設定の外部化
- 環境変数による設定管理
- 環境別の動作制御

### 4. 型安全性の確保
- TypeScriptインターフェースによる型定義
- カスタムデコレータによる型安全なデータ取得

### 5. エラーハンドリングの統一
- 一貫したエラーレスポンス形式
- 適切なHTTPステータスコードの設定

---

## 使用場面とベストプラクティス

### キャッシュ機能
- **使用場面**: 頻繁にアクセスされるデータの高速化
- **ベストプラクティス**: サイト別TTL設定、適切な無効化戦略

### ログ機能
- **使用場面**: デバッグ、監視、トラブルシューティング
- **ベストプラクティス**: 構造化ログ、適切なログレベル設定

### サイトコンテキスト
- **使用場面**: マルチテナント対応、サイト別処理
- **ベストプラクティス**: ミドルウェア→ガード→デコレータの順序

### 例外処理
- **使用場面**: エラーレスポンスの統一、セキュリティ向上
- **ベストプラクティス**: カスタム例外クラスの活用、適切なエラー情報の提供

Core層は、アプリケーション全体の基盤となる重要な層であり、他の層の実装品質と保守性に大きく影響します。適切な設計と実装により、スケーラブルで保守性の高いシステムを構築できます。
