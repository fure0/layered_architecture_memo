# Modules層とApplication層詳細ドキュメント

## 概要

Modules層は、NestJSの依存性注入システムを活用してアプリケーションの構成要素を組織化する層です。Application層は、レイヤードアーキテクチャにおいてビジネスロジックの調整とユースケースの実装を担当する層です。

## レイヤードアーキテクチャにおけるModules層とApplication層の重要な役割

### Modules層の役割

```
┌─────────────────────────────────────────────────────────────┐
│                    Modules Layer                             │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │   App Module    │  │ Service Module  │                   │
│  │  (ルートモジュール) │  │ (機能モジュール)  │                   │
│  └─────────────────┘  └─────────────────┘                   │
│           │                      │                          │
│           └──────────────────────┘                          │
│                      │                                      │
│              依存性注入とライフサイクル管理                      │
└─────────────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────┐
│              Presentation ← Application ← Domain             │
│                    ← Infrastructure                          │
└─────────────────────────────────────────────────────────────┘
```

#### 1. 依存性注入の統合管理
- **コンポーネントの組み立て**: 各層のクラスを適切に組み合わせ
- **ライフサイクル管理**: シングルトン、リクエストスコープなどの管理
- **インターフェースと実装の結合**: 抽象化と具象化の橋渡し

#### 2. アーキテクチャ境界の明確化
- **層間の依存関係制御**: 適切な依存方向の保証
- **機能の分離**: ビジネス機能ごとのモジュール分割
- **横断的関心事の統合**: Core層機能の各層への提供

### Application層の役割

```
┌─────────────────────────────────────────────────────────────┐
│                   Application Layer                          │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Services      │  │   Query/Command │  │     DTOs     │ │
│  │  (調整・制御)     │  │    Handlers     │  │  (データ転送)  │ │
│  │                 │  │   (CQRS実装)     │  │              │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                     Domain Layer                             │
│              (ビジネスルールとドメインロジック)                  │
└─────────────────────────────────────────────────────────────┘
```

#### 1. ユースケースの実装
- **ビジネスプロセスの調整**: 複数のドメインサービスの組み合わせ
- **トランザクション境界の管理**: データ整合性の保証
- **外部システムとの連携**: APIコール、メッセージング等の制御

#### 2. データフローの制御
- **入力データの変換**: Presentation層からDomain層への変換
- **出力データの整形**: Domain層からPresentation層への変換
- **バリデーションの実行**: ビジネスルールに基づく検証

#### 3. 技術的関心事の分離
- **キャッシュ戦略**: パフォーマンス最適化
- **ログ記録**: 監査とデバッグ情報の収集
- **エラーハンドリング**: 例外の適切な処理と変換

---

## Modules層の詳細

### 1. app.module.ts
**役割**: アプリケーションのルートモジュール

**内容**:
```typescript
@Module({
  imports: [LoggerModule, ServiceModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

**レイヤードアーキテクチャにおける重要性**:
- **アプリケーション全体の構成管理**: 全機能モジュールの統合点
- **Core層の基盤機能提供**: LoggerModuleによる横断的ログ機能
- **機能モジュールの組み込み**: ServiceModuleによるビジネス機能の提供

**なぜ必要か**:
- NestJSアプリケーションのエントリーポイント
- 依存性注入コンテナの初期化
- アプリケーション全体の設定とライフサイクル管理

**いつ使用するか**:
- アプリケーション起動時
- 新しい機能モジュールを追加する時
- 全体的な依存関係を変更する時

### 2. service.module.ts
**役割**: サービス機能の依存性注入設定

**内容**:
- **CQRS実装**: QueryHandlersの登録
- **リポジトリパターン**: インターフェースと実装の結合
- **ミドルウェア設定**: サイトコンテキストの適用

**レイヤードアーキテクチャにおける重要性**:
- **層間の依存関係制御**: 各層のコンポーネントを適切に結合
- **インターフェース分離原則**: ドメイン層のインターフェースとインフラ層の実装を分離
- **横断的関心事の統合**: キャッシュ、データベース、ログ機能の統合

**主要な依存性注入**:
```typescript
providers: [
  ...QueryHandlers,                    // CQRS実装
  ServiceApplicationService,           // アプリケーションサービス
  {
    provide: SERVICE_REPOSITORY_TOKEN, // リポジトリパターン
    useClass: PrismaServiceRepository,
  },
]
```

**なぜ必要か**:
- 依存性逆転の原則の実現
- テスタビリティの向上
- 疎結合な設計の実現

**いつ使用するか**:
- サービス機能の初期化時
- 新しいクエリハンドラーを追加する時
- リポジトリ実装を変更する時

---

## Application層の詳細

### DTOs（Data Transfer Objects）

#### 1. service-list-result.dto.ts
**役割**: サービス一覧の検索結果を表現するDTO

**主要機能**:
- **検索結果の構造化**: サービス一覧、ページネーション、フィルタ情報
- **メタデータ管理**: 統計情報、ページング情報の計算
- **キャッシュ対応**: プレーンオブジェクトとの相互変換

**レイヤードアーキテクチャにおける重要性**:
- **層間データ転送**: Domain層のエンティティをApplication層で集約
- **ビジネスロジックの分離**: 表示用ロジックをDomain層から分離
- **パフォーマンス最適化**: キャッシュ機能との連携

**主要メソッド**:
```typescript
getPaginationMeta()     // ページネーション情報
getStatistics()         // 統計情報
hasFilters()           // フィルタ適用状況
toPlainObject()        // キャッシュ用変換
```

**なぜ必要か**:
- 複雑な検索結果の構造化
- フロントエンドとの明確なインターフェース定義
- キャッシュ戦略の実現

**いつ使用するか**:
- サービス一覧API呼び出し時
- 検索結果のキャッシュ時
- ページネーション処理時

#### 2. service-search-params.dto.ts
**役割**: サービス検索パラメータの管理とバリデーション

**主要機能**:
- **リクエスト変換**: HTTPパラメータからDTOへの変換
- **バリデーション**: 入力値の妥当性チェック
- **デコード処理**: 文字エンコーディングの正規化

**レイヤードアーキテクチャにおける重要性**:
- **入力データの正規化**: Presentation層からの生データを構造化
- **ビジネスルールの適用**: 検索条件の制約をApplication層で管理
- **型安全性の確保**: TypeScriptの型システムを活用

**バリデーション項目**:
```typescript
- ページ番号: 1以上
- 件数: 1〜100件
- ソートフィールド: 許可された項目のみ
- 検索キーワード: 100文字以内
- ステータス: 定義された値のみ
- 企業ID: 正しい形式
- 日付範囲: 論理的な順序
```

**なぜ必要か**:
- 入力データの品質保証
- セキュリティの向上
- エラーの早期発見

**いつ使用するか**:
- API呼び出し時の入力処理
- 検索条件の構築時
- バリデーションエラーの検出時

### Queries（CQRS実装）

#### 1. get-services.query.ts
**役割**: CQRSパターンのクエリオブジェクト定義

**クエリ種類**:
- **GetServicesQuery**: 管理者用全サービス取得
- **GetServicesForCompanyQuery**: 企業用自社サービス取得
- **GetServicesForPublicQuery**: ポータル用公開サービス取得

**レイヤードアーキテクチャにおける重要性**:
- **責務の分離**: 読み取り処理の専用化
- **スケーラビリティ**: 読み取り最適化の実現
- **保守性**: クエリロジックの独立性

**なぜ必要か**:
- CQRSパターンの実装
- サイト別処理の明確化
- 型安全なクエリ実行

**いつ使用するか**:
- サービス一覧取得時
- サイト別データアクセス時
- 読み取り専用処理時

#### 2. get-services.handler.ts
**役割**: クエリの具体的な実行処理

**主要機能**:
- **アクセス制御**: サイト別権限チェック
- **検索仕様適用**: ドメイン層の仕様パターン活用
- **データフィルタリング**: アクセス可能データの絞り込み
- **エラーハンドリング**: 構造化ログとエラー変換

**レイヤードアーキテクチャにおける重要性**:
- **ドメインロジックの活用**: Specification、Policyパターンの使用
- **インフラ層との連携**: リポジトリパターンによるデータアクセス
- **横断的関心事の統合**: ログ、エラーハンドリングの適用

**処理フロー**:
```typescript
1. アクセス権限チェック (Policy)
2. 検索仕様構築 (Specification)
3. バリデーション実行
4. リポジトリからデータ取得
5. アクセス可能データのフィルタリング
6. 結果の構造化
```

**なぜ必要か**:
- ビジネスロジックの実行
- セキュリティの確保
- データ整合性の保証

**いつ使用するか**:
- クエリ実行時
- ビジネスルール適用時
- データアクセス制御時

### Services

#### 1. service-application.service.ts
**役割**: アプリケーションサービスの中核実装

**主要機能**:
- **サイト別処理振り分け**: admin/corporate/portalの処理分岐
- **キャッシュ戦略**: 高速化とパフォーマンス最適化
- **エラーハンドリング**: 包括的な例外処理
- **バリデーション**: 入力データとサイトコンテキストの検証

**レイヤードアーキテクチャにおける重要性**:
- **ユースケースの実装**: ビジネスプロセスの中心的制御
- **層間の調整**: Presentation、Domain、Infrastructureの連携
- **技術的関心事の統合**: キャッシュ、ログ、エラー処理の一元化

**サイト別処理戦略**:
```typescript
ADMIN: 全データアクセス可能
CORPORATE: 自社データのみアクセス
PORTAL: 公開データのみアクセス
```

**キャッシュ戦略**:
```typescript
1. キャッシュから取得試行
2. キャッシュミス時はDB取得
3. 結果をキャッシュに保存
4. サイト別TTL適用
```

**なぜ必要か**:
- ビジネスロジックの中央集権化
- パフォーマンスの最適化
- 一貫したエラーハンドリング

**いつ使用するか**:
- ビジネス処理の実行時
- 複数の層を跨ぐ処理時
- キャッシュ戦略が必要な時

---

## Application層の設計パターン

### 1. CQRSパターン
**目的**: 読み取りと書き込みの責務分離

**利点**:
- **パフォーマンス最適化**: 読み取り専用の最適化
- **スケーラビリティ**: 読み取りと書き込みの独立スケーリング
- **保守性**: 処理の明確な分離

### 2. DTOパターン
**目的**: 層間のデータ転送最適化

**利点**:
- **データ構造の最適化**: 用途に応じた構造設計
- **バリデーションの集約**: 入力検証の一元化
- **型安全性**: TypeScriptの型システム活用

### 3. Application Serviceパターン
**目的**: ユースケースの実装とビジネスロジック調整

**利点**:
- **ビジネスプロセスの明確化**: 処理フローの可視化
- **再利用性**: 共通処理の抽象化
- **テスタビリティ**: 単体テストの容易性

---

## 使用場面とベストプラクティス

### Modules層
- **使用場面**: アプリケーション構成の定義、依存性注入の設定
- **ベストプラクティス**: 
  - 機能ごとのモジュール分割
  - 適切な依存関係の定義
  - ライフサイクルの明確化

### Application層
- **使用場面**: ビジネスロジックの調整、ユースケースの実装
- **ベストプラクティス**:
  - 薄いApplication Service
  - 適切なDTO設計
  - CQRSパターンの活用

### エラーハンドリング
- **使用場面**: 例外の適切な処理と変換
- **ベストプラクティス**:
  - 構造化ログの活用
  - カスタム例外の定義
  - 適切なHTTPステータスコード

Application層は、レイヤードアーキテクチャにおいてビジネスロジックの調整役として重要な役割を果たし、各層の連携を円滑にし、システム全体の品質と保守性を向上させます。
