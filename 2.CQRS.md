## CQRS パターン

### CQRS の概念

> 一言サマリ
- 読み取り（Query）と書き込み（Command）を、コードと責務のレベルで完全に分離するパターン

> なぜ使うのか？
- 読み取りと書き込みの目的が異なるため
  - 読み取り: 高速で柔軟な参照が目的（キャッシュ/ソート/フィルタなどの最適化）
  - 書き込み: ビジネスルールとデータ整合性が目的（トランザクション/バリデーションに注力）
- 分離することで、それぞれを独立に最適化でき、変更の影響範囲を縮小できる

> どのように分けるのか？
- Query: 状態を変更しないリクエスト`QueryBus` → `QueryHandler`
- Command: 状態を変更するリクエスト`CommandBus` → `CommandHandler`

> メリット（やさしく）
- 読み取りの速度・体験を個別に最適化できる
- 書き込み（変更）ロジックを一箇所で安全に管理できる
- テストが簡単（読み取り/書き込みをそれぞれ単体テスト）
- 規模が大きくなってもルールが保たれ、コードが絡みにくい

> こういう場合に特に効果的
- 読み取りトラフィックが書き込みより大幅に多い場合
- 読み取りモデルをキャッシュ/検索エンジンなどで別途最適化したい場合
- 複雑なビジネスルールで書き込みトランザクションを厳密に管理したい場合

### "Bus" とは？

> Bus の意味
- **Bus** は「メッセージバス（Message Bus）」の概念から来ている
- 異なるコンポーネント間でメッセージ（Query/Command）を送受信するための通信路
- 複数のハンドラー（Handler）にメッセージをルーティングする中継システム

> なぜ "Bus" という名前なのか？
- 実際のバスが多くの停留所（ハンドラー）を巡回して乗客（メッセージ）を運ぶように、Bus も複数のハンドラーを巡回してメッセージを配送する
- ラテン語の「omnibus（すべての人のために）」から来たバスと同様の概念
- 中継・配送の役割を果たす中央集約的なメカニズムを表現

> Bus の役割
- **ルーティング**: Query/Command を受け取り、適切な Handler に転送
- **分離**: 呼び出し元（Service）と Handler を疎結合に保つ
- **拡張性**: 新しい Handler を追加しても呼び出し元のコードを変更せずに済む

```
Service → QueryBus/CommandBus → Handler
         （中継・配送の役割）
```

### QueryBus の使用
```typescript
const query = new GetNewsListQuery(searchParams);
const domainResult = await this.queryBus.execute(query);
```

### CommandBus の使用
```typescript
const command = new CreateNewsCommand({ title, content, authorId });
await this.commandBus.execute(command);
```
	
### Repository の直接使用	
```typescript
const news = await this.newsRepository.findById(id);
```

### QueryBus を使う利点
> 関心の分離（Separation of Concerns）
- Service が永続化実装（Repository）に直接依存せず、読み取りロジックを QueryHandler に委譲できるため、変更・拡張が容易
- リポジトリの差し替え/複数データソースの構成がしやすい
- QueryBus: ビジネスロジックとデータアクセスロジックを分離
- Repository: データアクセスのみを担当

> 拡張性と柔軟性
- QueryHandler に複雑なビジネスロジックを追加可能。
- 複数データソースの組み合わせ、キャッシュ戦略、ロギング等を Handler で処理
- Service はクエリ実行に専念できる

> テスト容易性
- QueryHandler を独立してテスト可能
- Mock の注入が明確

> 一貫性
- すべての参照処理が同じパターンに従う
- コードベース全体の一貫性を維持

### CommandBus を使う利点
> 意図の分離（書き込みを別に）
- Command は「状態を変える処理」のみを扱う。読み取りと書き込みをはっきり分けられる

> 変更ロジックを一箇所で管理
- 副作用を伴う変更ロジックを Handler に集約でき、保守が容易

> トランザクションをまとめやすい
- Handler 単位でトランザクションを開始/終了しやすく、データ整合性を保ちやすい

> 共通機能の追加が簡単
- 認証/検証/ロギング/再試行などの共通機能をミドルウェアとして簡単に付与できる

> 重複実行防止と再試行
- 冪等キー等で重複実行を防ぎ、失敗時も安全に再試行できる

> テストが簡単
- Handler だけを個別にテストでき、Service 層はよりシンプルになる