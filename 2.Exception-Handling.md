# 例外処理の動作原理

## 概要

`throw new`で発生させた例外がどのようにHTTPレスポンスに変換されるか、その詳細なメカニズムを解説

```typescript
throw new BadRequestException(
  `この${favoriteDivName}は既にお気に入りに登録されています`,
);

throw new InternalServerErrorException(
  'サービス一覧の取得中に予期しないエラーが発生しました',
);
```

## エラーレスポンスの形式

すべてのエラーレスポンスは以下の形式に従う

```typescript
interface ErrorResponse {
  success: false;
  error: {
    code: string;        // エラーコード（例: "BAD_REQUEST"）
    message: string;      // エラーメッセージ（人間が読める形式）
    status: number;      // HTTPステータスコード（例: 400）
    details?: unknown;   // 追加の詳細情報（オプション）
  };
}
```

## 実際の使用例

### 例1: お気に入り登録の重複チェック

```typescript
// favoriteInfo.service.ts
checkFavoriteInfoExists(action: string, division: number, length: number): void {
  const favoriteDivName = this.getFavoriteDivName(division);

  if (action === 'CREATE') {
    if (length > 0) {
      throw new BadRequestException(
        `この${favoriteDivName}は既にお気に入りに登録されています`,
      );
    }
  }
}
```

**レスポンス例**:
```json
{
  "success": false,
  "error": {
    "code": "BAD_REQUEST",
    "message": "このサービスは既にお気に入りに登録されています",
    "status": 400
  }
}
```

### 例2: お気に入り数制限チェック

```typescript
// favoriteInfo.service.ts
async checkFavoriteCountLimit(memberId: string, favoriteDiv: number): Promise<void> {
  const favoriteCount = await this.getFavoriteCount(memberId, favoriteDiv);
  const favoriteDivName = this.getFavoriteDivName(favoriteDiv);

  if (favoriteCount > 50) {
    throw new CustomBadRequestException(
      'FAVORITE_COUNT_LIMIT_EXCEEDED',
      `${favoriteDivName}お気に入り数が50を超えています`,
    );
  }
}
```

**レスポンス例**:
```json
{
  "success": false,
  "error": {
    "code": "FAVORITE_COUNT_LIMIT_EXCEEDED",
    "message": "サービスお気に入り数が50を超えています",
    "status": 400
  }
}
```

### 例3: 内部サーバーエラー

```typescript
// favoriteInfo.service.ts
catch (error) {
  this.logger.error('お気に入り情報登録エラー', {
    error: error instanceof Error ? error.message : String(error),
    // ...
  });

  throw new InternalServerErrorException(
    'お気に入り情報の登録中に予期しないエラーが発生しました',
  );
}
```

**レスポンス例**:
```json
{
  "success": false,
  "error": {
    "code": "INTERNAL_SERVER_ERROR",
    "message": "お気に入り情報の登録中に予期しないエラーが発生しました",
    "status": 500
  }
}
```

## 例外処理の全体フロー

```
1. Serviceで例外が発生
   ↓
   throw new BadRequestException('メッセージ')
   
2. NestJSフレームワークが例外をキャッチ
   ↓
   (コントローラー/サービス層でthrowされた例外を自動検知)
   
3. HttpExceptionFilterが例外を処理
   ↓
   (main.tsで登録されたグローバルフィルター)
   
4. 例外タイプに応じてHTTPレスポンスを生成
   ↓
   
5. JSONレスポンスを返却
```

## 主要な構成要素

### 1. 例外クラスの構造

すべてのカスタム例外は`BaseException`を継承し、`statusCode`と`code`を持つ

#### BaseException（基底クラス）

```typescript
src/core/exceptions/base.exception.ts 1:12

export abstract class BaseException extends Error {
  abstract readonly code: string;
  abstract readonly statusCode: number;

  constructor(
    message: string,
    public readonly details?: Record<string, unknown>,
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}
```

#### 具体例：BadRequestException

```typescript
src/core/exceptions/common.exceptions.ts 69:79

// 400 Bad Request
export class BadRequestException extends BaseException {
  readonly code = 'BAD_REQUEST';
  readonly statusCode = 400;

  constructor(
    message: string = '不正なリクエストです',
    details?: Record<string, unknown>,
  ) {
    super(message, details);
  }
}
```

#### 利用可能な例外クラス

- `NotFoundException` (404) - リソースが見つからない場合
- `UnauthorizedException` (401) - 認証が必要な場合
- `AccessDeniedException` (403) - アクセスが拒否された場合
- `BadRequestException` (400) - 不正なリクエスト
- `CustomBadRequestException` (400) - カスタムコード付きのバリデーションエラー
- `ValidationException` (422) - バリデーションエラー
- `ConflictException` (409) - リソース競合
- `TooManyRequestsException` (429) - レート制限超過
- `InternalServerErrorException` (500) - サーバーエラー

### 2. グローバル例外フィルターの登録

アプリケーション起動時に`main.ts`でグローバルフィルターが登録される：

```typescript
src/main.ts 37:39

// グローバルフィルターの設定
logger.log('🔧 グローバル例外フィルターを設定中...');
app.useGlobalFilters(new HttpExceptionFilter());
```

この設定により、アプリケーション全体で発生するすべての例外が自動的にフィルターで処理される

### 3. 例外フィルターの動作原理

#### HttpExceptionFilterの実装

```typescript
src/core/presentation/filters/http-exception.filter.ts 20:71

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = 500;
    let errorResponse: ErrorResponse = {
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'サーバーエラーが発生しました',
        status: 500,
      },
    };

    if (exception instanceof BaseException) {
      status = exception.statusCode;
      errorResponse = {
        success: false,
        error: {
          code: exception.code,
          message: exception.message,
          details: exception.details,
          status: exception.statusCode,
        },
      };
    } else if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();
      errorResponse = {
        success: false,
        error: {
          code: 'HTTP_EXCEPTION',
          message: exception.message,
          details: exceptionResponse,
          status,
        },
      };
    }

    // エラーログを記録
    console.error('Exception caught:', {
      url: request.url,
      method: request.method,
      error: exception instanceof Error ? exception.message : exception,
      stack: exception instanceof Error ? exception.stack : undefined,
    });

    response.status(status).json(errorResponse);
  }
}
```

#### フィルターの処理フロー

1. **例外のキャッチ**: `@Catch()`デコレータにより、すべての例外をキャッチ
2. **HTTPコンテキストの取得**: `ArgumentsHost`からExpressの`Request`と`Response`オブジェクトを取得
3. **例外タイプの判定**:
   - `instanceof BaseException`: カスタム例外の場合、例外オブジェクトの`statusCode`、`code`、`message`、`details`を使用
   - `instanceof HttpException`: NestJSの標準例外の場合、`getStatus()`と`getResponse()`を使用
   - その他: デフォルトで500エラーを返す
4. **エラーログの記録**: コンソールにエラー情報を出力
5. **HTTPレスポンスの生成**: `response.status(status).json(errorResponse)`でJSONレスポンスを返却

## 動作ステップの詳細説明

### ステップ1: Serviceで例外が発生

サービス層でビジネスロジックの結果として例外をスローする：

```typescript
src/modules/favorites/application/services/favoriteInfo.service.ts 609:615

if (action === 'CREATE') {
  // お気に入り登録 重複の場合
  if (length > 0) {
    throw new BadRequestException(
      `この${favoriteDivName}は既にお気に入りに登録されています`,
    );
  }
}
```

### ステップ2: NestJSフレームワークが例外をキャッチ

- コントローラー、サービス、ミドルウェアなど、任意の層で`throw`された例外がNestJSフレームワークによって自動的に検知される
- 処理されていない例外は、グローバル例外フィルターに自動的に転送される

### ステップ3: HttpExceptionFilterが例外を処理

フィルターは以下のロジックで例外を処理する：

```typescript
if (exception instanceof BaseException) {
  // カスタム例外の場合
  status = exception.statusCode;  // 例: 400
  errorResponse = {
    success: false,
    error: {
      code: exception.code,           // 例: "BAD_REQUEST"
      message: exception.message,      // 例: "このサービスは既にお気に入りに登録されています"
      details: exception.details,     // 追加の詳細情報（オプション）
      status: exception.statusCode,   // 例: 400
    },
  };
}
```

### ステップ4: HTTPレスポンスの生成

変換されたエラーレスポンスがクライアントに返される：

```json
HTTP 400 Bad Request
{
  "success": false,
  "error": {
    "code": "BAD_REQUEST",
    "message": "このサービスは既にお気に入りに登録されています",
    "status": 400
  }
}
```

## 重要なポイント

### 1. `@Catch()`デコレータ

- パラメータなしで使用すると、すべての例外をキャッチします
- 特定の例外のみをキャッチしたい場合は、`@Catch(BadRequestException)`のように指定可能

### 2. `instanceof`チェック

- 例外のタイプに応じて異なる処理を実行
- カスタム例外（`BaseException`）とNestJS標準例外（`HttpException`）を区別して処理

### 3. 自動レスポンス変換

- 例外オブジェクトのプロパティ（`statusCode`、`code`、`message`、`details`）を自動的にJSONレスポンスに変換
- 開発者は例外をスローするだけで、HTTPレスポンスの構築を意識する必要はない

### 4. 一貫したレスポンス形式

- すべてのエラーが統一された構造のJSONレスポンスとして返される
- フロントエンドでのエラーハンドリングが容易になる

## まとめ

- **フレームワークによる自動処理**: NestJSが例外を自動的にキャッチし、グローバルフィルターに転送
- **統一されたレスポンス形式**: すべてのエラーが同じ構造のJSONレスポンスとして返される
- **開発者体験の向上**: サービス層ではビジネスロジックに集中し、例外をスローするだけでHTTPレスポンスが自動生成される
- **保守性の向上**: 例外処理のロジックが一箇所（`HttpExceptionFilter`）に集約され、変更が容易

この仕組みにより、アプリケーション全体で一貫したエラーハンドリングが実現され、フロントエンドとバックエンドの間で明確なエラー契約が確立される

