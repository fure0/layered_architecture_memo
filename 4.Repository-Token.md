# Repository Token の説明

## 概要

Repository Tokenは、NestJSの依存性注入(DI)システムにおいて、インターフェースベースの抽象化を実現するための重要なメカニズムである

## なぜRepository Tokenが必要なのか

### 1. インターフェースベースの依存性注入

```typescript
// banners.module.ts
{
  provide: BANNER_REPOSITORY_TOKEN,
  useClass: PrismaBannerRepository,
}
```

**仕組み**:
- 抽象的な`BannerRepositoryInterface`を定義
- 具体的な実装`PrismaBannerRepository`を注入
- ハンドラーはインターフェースのみに依存

```typescript
// banner-handler.ts
constructor(
  @Inject(BANNER_REPOSITORY_TOKEN)
  private readonly bannerRepository: BannerRepositoryInterface,
) {}
```

### 2. 主な利点

> 実装の切り替えが容易

```typescript
// 現在: Prisma使用
provide: BANNER_REPOSITORY_TOKEN,
useClass: PrismaBannerRepository,

// 将来: MongoDBに変更
provide: BANNER_REPOSITORY_TOKEN,
useClass: MongoBannerRepository,  // ハンドラーコード変更不要！
```

> テストが簡単

```typescript
// テスト用モックの差し替え
provide: BANNER_REPOSITORY_TOKEN,
useClass: MockBannerRepository,  // テスト用モックオブジェクト
```

> レイヤードアーキテクチャとの統合

```
Domain Layer      → インターフェース定義
Infrastructure    → 具体的実装
Application       → インターフェースのみに依存
```

### 3. Symbol を使用する理由

```typescript
// banner.repository.token.ts
export const BANNER_REPOSITORY_TOKEN = Symbol('BannerRepository');
```

**Symbolの利点**:
- **一意性の保証**: 文字列との衝突を防ぐ
- **型安全性**: TypeScriptの型チェックと相性が良い
- **グローバル名前空間の汚染を防止**: Symbolはユニークな識別子

### 4. Tokenを使わない場合の問題点

#### ❌ 直接クラス注入は避けるべき

```typescript
// 間違った例: 具体的なクラスに直接依存
constructor(
  private readonly bannerRepository: PrismaBannerRepository,  // 具体クラスに依存！
)
```

**問題点**:
- データベース変更時の影響が大きい
- テスト時のモック化が困難
- レイヤー間の結合が強くなる
- 保守性が低下

## Repository Token パターンの構成要素

### 1. Token定義

```typescript
// domain/repositories/banner.repository.token.ts

// リポジトリインターフェースのトークン
export const BANNER_REPOSITORY_TOKEN = Symbol('BannerRepository');
```

### 2. インターフェース定義

```typescript
// domain/repositories/banner.repository.interface.ts
export interface BannerRepositoryInterface {
  getBannerList(
    searchParams: BannerListSearchParamsDto,
  ): Promise<BannerQueryResult>;
}
```

### 3. 実装クラス

```typescript
// infrastructure/repositories/prisma-banner.repository.ts
@Injectable()
export class PrismaBannerRepository implements BannerRepositoryInterface {
  constructor(
    private readonly prisma: PrismaService,
    @Inject(LOGGER_TOKEN) private readonly logger: LoggerInterface,
  ) {}

  async getBannerList(
    searchParams: BannerListSearchParamsDto,
  ): Promise<BannerQueryResult> {
    // 具体的な実装...
  }
}
```

### 4. モジュールでの登録

```typescript
// banners.module.ts
@Module({
  imports: [CqrsModule, PrismaModule, CacheModule],
  controllers: [BannerController],
  providers: [
    ...QueryHandlers,
    BannerService,
    {
      provide: BANNER_REPOSITORY_TOKEN,
      useClass: PrismaBannerRepository,
    },
  ],
  exports: [BannerService, ...QueryHandlers, BANNER_REPOSITORY_TOKEN],
})
```

### 5. ハンドラーでの注入

```typescript
// application/queries/banner-handler.ts
@Injectable()
@QueryHandler(GetBannerListQuery)
export class GetBannerListHandler implements IQueryHandler<GetBannerListQuery> {
  constructor(
    @Inject(BANNER_REPOSITORY_TOKEN)
    private readonly bannerRepository: BannerRepositoryInterface,
    @Inject(LOGGER_TOKEN) private readonly logger: LoggerInterface,
  ) {}

  async execute(query: GetBannerListQuery): Promise<BannerQueryResult> {
    return this.bannerRepository.getBannerList(query.searchParams);
  }
}
```

## まとめ

| 項目 | Token使用 | 直接注入 |
|------|-----------|----------|
| **実装切替** | ✅ 容易 | ❌ 困難 |
| **テスト** | ✅ 簡単 | ❌ 複雑 |
| **結合度** | ✅ 疎結合 | ❌ 密結合 |
| **保守性** | ✅ 高い | ❌ 低い |
| **拡張性** | ✅ 高い | ❌ 低い |

**Repository Token**は、レイヤードアーキテクチャにおいて重要な役割を果たし、システム全体の**柔軟性**、**テスト容易性**、**保守性**を向上させる

